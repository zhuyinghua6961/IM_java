# IM 即时通讯系统后端技术总结（不含广场模块）

> 说明：本文件总结的是整个 IM 系统中**除广场模块（im-square-service）以外**的后端实现，包括用户服务、好友&群组、消息&通知、认证安全、存储与缓存等，并扩展出可用于面试的问题和简历写法示例。

---

## 1. 整体架构与技术栈

### 1.1 架构风格

- **微服务拆分**
  - `im-user-service`：用户、好友、群组、白名单、黑名单等用户域能力。
  - `im-message-service`：WebSocket 连接、单聊/群聊消息、通知推送。
  - （可选）moments、file、gateway 等服务按业务拆分，方便水平扩展。
- **前后端分离**
  - 后端基于 Spring Boot 3.x，提供 REST + WebSocket 接口。
  - 前端基于 Vue3 + Vite + Element Plus，通过 Axios 与后端交互。

### 1.2 核心技术栈

- **基础框架**：Spring Boot 3.x
- **ORM 与持久层**：MyBatis / MyBatis-Plus，XML 映射 + 注解 Mapper 结合
- **数据库**：MySQL 8（库：`im_chat`）
- **缓存与会话**：Redis（token 缓存、会话状态、热点数据等）
- **实时通信**：Spring WebSocket + STOMP 协议
- **消息/通知**：自建通知表 + WebSocket 推送（文档中预留 Kafka，当前实现主要用 DB+WS）
- **认证与安全**：JWT + Spring 拦截器，BCrypt 密码加密
- **对象存储**：MinIO（头像、图片、文件）
- **配置与网关**：Nacos、Spring Cloud Gateway（文档中规划，方便水平扩展）
- **文档与调试**：Knife4j (Swagger UI)

**可写在简历 / 面试中的亮点**：
- 设计并实现了基于 **Spring Boot + MyBatis + Redis + WebSocket** 的即时通讯系统后端，采用微服务拆分用户域与消息域，接口文档统一由 Swagger/Knife4j 管理。

---

## 2. 用户域（im-user-service）

### 2.1 用户管理

**功能点**：注册、登录、登出、资料修改、用户搜索、短信验证码、修改密码等。

**关键技术实现**：
- **密码加密存储**：使用 BCrypt（`BCryptPasswordEncoder`）对密码加盐哈希，避免明文或可逆加密。
- **JWT 认证**：
  - 登录成功后签发 JWT：包含 `userId`、过期时间等 claim。
  - 前端后续所有接口通过 `Authorization: Bearer {token}` 传递。
  - 用户服务和消息服务各自有 JWT 拦截器，从请求头解析 token，并写入 `UserContext`（ThreadLocal）。
- **Redis 作为 Token 黑名单/会话缓存**：
  - 登录时把 token 写入 Redis（可以做单点登录、手动失效）。
  - 登出时从 Redis 删除 token，后续请求即视为未认证。
- **用户信息查询与更新**：
  - `GET /api/user/info/{userId}`：按 ID 查询，过滤已禁用用户。
  - `PUT /api/user/info`：允许修改头像、昵称、签名等，使用当前登录用户 ID，避免越权更新他人信息。
- **用户搜索**：
  - 支持按用户名/手机号搜索，做精确匹配，方便加好友。

**典型面试题**：
- 如何设计基于 JWT 的认证体系，保证 **无状态** 的同时又可以 **手动失效某个 token**？
- 为什么选择 BCrypt 而不是 MD5？如何防止彩虹表攻击？
- 用户资料更新接口在后端如何做 **权限控制** 和 **字段级校验**？

**简历示例表述**：
- 负责用户中心模块设计与开发，实现 **注册/登录/登出、资料维护、用户搜索** 等功能，引入 **JWT + Redis** 的认证方案，并使用 **BCrypt** 存储密码，提升系统安全性。

---

### 2.2 好友系统

**主要功能**：
- 好友申请：发送、列表、处理（同意/拒绝）
- 好友关系：双向维护、删除（软删除）、备注名
- 黑名单 & 免打扰
- 内部接口：供消息服务检查黑名单

**实现细节**：

1. **好友关系表设计** `friend`
   - 字段：`user_id`, `friend_id`, `remark`, `status`, `muted` 等。
   - **唯一索引** `uk_user_friend(user_id, friend_id)` 保证一对关系唯一。
   - `status` 支持软删除，可恢复好友关系。

2. **双向好友维护**
   - 同意好友申请时，分别为 `A->B` 和 `B->A` 建立 / 恢复记录。
   - 删除好友时软删除双方记录，保证语义上互相都不是好友。

3. **好友申请流程**
   - `friend_request` 表存 pending/同意/拒绝状态，带申请留言。
   - 发送申请前：
     - 校验不能加自己；
     - 对方是否存在；
     - 是否已经是好友；
     - 是否已有 pending 申请（避免刷接口）。
   - 申请处理时使用事务，保证：
     - 更新 `friend_request` 状态；
     - 更新/插入 `friend` 表两条记录。
   - 处理结果通过 WebSocket 通知申请方（消息服务）。

4. **黑名单与免打扰**
   - 黑名单表 `blacklist` + 接口：拉黑/取消拉黑、拉黑列表、检查是否被拉黑。
   - 免打扰字段 `muted`：保存在 `friend` 表，消息服务可根据该字段控制离线通知。
   - 提供内部接口 `/api/friend/internal/check-blocked`，供消息服务通过 HTTP 调用，在发送消息前判断是否应该拒绝或只保存不推送。

**典型面试题**：
- 如何设计 **好友申请 + 好友关系** 的数据结构，以支持双向维护、软删除和恢复？
- 如果有大量并发的好友申请，如何避免重复加好友和状态错乱？（涉及唯一索引、幂等和事务）
- “拉黑”和“删除好友”的语义区别是什么？后端如何设计？

**简历示例表述**：
- 设计并实现了 **好友系统**，包括好友申请、双向关系维护、黑名单和免打扰等能力，使用事务保证关系一致性，并通过 WebSocket 与消息服务联动，实现 **实时好友申请/处理通知**。

---

### 2.3 群组 & 白名单系统

**群组核心能力**：
- 群组创建 / 解散（owner 权限）
- 群成员管理：邀请、加入、退出
- 角色管理：群主 / 管理员 / 普通成员
- 群邀请（带过期时间）、白名单机制

**实现细节**：

1. **群表 & 群成员表**
   - `group`：记录群基础信息（名称、头像、公告、owner、最大人数等）。
   - `group_member`：`group_id + user_id` 唯一约束，带 `role` 表示成员角色，`status` 控制是否退群。

2. **邀请 & 白名单**
   - `group_invitation` 表：记录邀请信息和状态，带过期时间字段，支持“超时自动失效”。
   - 白名单：用户可以维护白名单列表，创建群时可以 **自动拉白名单好友进群**，无需逐个发邀请，极大优化体验。

3. **权限模型**
   - 群主：设置管理员、踢人、解散群、修改公告。
   - 管理员：邀请成员、踢普通成员。
   - 普通成员：发送消息、修改自己群昵称、退群。
   - 接口层统一通过当前登录用户 ID 和 `group_member.role` 组合校验权限。

4. **通知与 WebSocket**
   - 群邀请和处理结果（同意/拒绝）会通过消息服务的通知体系推送给相关用户。
   - 使用持久化通知表 + WebSocket 推送实现“既能离线补齐，又能实时感知”。

**典型面试题**：
- 如何在关系型数据库中设计群组 / 成员 / 邀请表，支持角色权限和过期邀请？
- 如何处理“群主不能直接退群”“转让群主”等边界条件？
- 白名单机制对业务的意义是什么，后端如何实现 **自动加入群**？

**简历示例表述**：
- 负责群组与白名单模块，实现 **群创建/邀请/加入/退群/角色管理** 等完整流程，支持群邀请过期机制与白名单一键入群，显著简化用户操作；通过角色字段与集中权限校验保证群操作安全。

---

## 3. 消息与通知域（im-message-service）

### 3.1 WebSocket 实时通信

**功能点**：
- WebSocket 连接建立与关闭
- STOMP 协议消息路由
- 心跳保活、自动重连（前端）
- JWT 鉴权 + 用户会话绑定

**实现细节**：
- 使用 `spring-websocket` + STOMP：
  - 服务器维护 `userId -> WebSocketSession` 的映射。
  - 客户端订阅不同目的地，例如：
    - `/topic/chat/{conversationId}` 群聊
    - `/queue/chat/{userId}` 单聊
    - `/queue/notification/{userId}` 系统/好友/群组通知
- 连接鉴权：
  - 在 STOMP `CONNECT` 时附带 JWT token，后端在 `HandshakeInterceptor` 或 `ChannelInterceptor` 里解析、验证，绑定到 session。
  - 拒绝非法连接，防止未登录用户占用资源。

**典型面试题**：
- HTTP 与 WebSocket 的区别？为什么 IM 必须用 WebSocket？
- 如何在 Spring 中做到 WebSocket 鉴权与用户绑定？
- 如何设计心跳机制、防止长连接资源泄露？

**简历示例表述**：
- 基于 **Spring WebSocket + STOMP** 实现 IM 实时通信通道，支持单聊/群聊/系统通知的多目的地路由，并在连接建立阶段完成 **JWT 鉴权与用户会话绑定**。

---

### 3.2 消息存储与会话管理

（当前代码中历史消息部分是 MVP / 待完善，但表结构已完整设计，可在面试中重点讲“设计能力”）

**表设计**：
- `message`：单条消息记录，包含发送者、接收者（用户或群），消息类型、内容 / 媒体 URL、状态（撤回/正常）、发送时间等。
- `message_read`：消息已读表，用 `(message_id, user_id)` 唯一索引记录谁已读了这条消息。
- `conversation`：会话维度（类似微信会话列表），记录：
  - `user_id`：会话归属人
  - `target_id`：对端用户或群
  - `chat_type`：单聊/群聊
  - `last_msg_id`：会话内最后一条消息
  - `unread_count`：该用户未读数

**设计要点**：
- 发送消息时：
  - 写入 `message` 表。
  - 更新双方（或所有群成员）的 `conversation.last_msg_id` 和 `unread_count`。
- 读消息时：
  - 在该会话内将某一时间点之前的消息标记为已读，插入 `message_read` 记录。
  - 同时更新会话的 `unread_count`。

**典型面试题**：
- 如何在数据库层面设计一个支持单聊和群聊的消息系统？
- 未读数是如何维护的？如何避免在高并发下未读数“回跳/不准”？
- 历史消息分页查询时如何设计索引和查询条件？

**简历示例表述**：
- 设计了 **消息表 / 已读表 / 会话表** 三层结构，支持多终端同步的未读计数与历史消息查询，并为后续消息撤回、漫游方案预留扩展点。

---

### 3.3 通知系统（非广场）

> 这里指好友申请、群邀请等消息服务内部的通知体系，广场通知属于类似思路，这里按“通用通知系统”来总结。

**核心思路**：
- **持久化表** + **WebSocket 推送** 结合：
  - 表记录所有通知（谁、因为什么动作、附加信息、是否已读、时间）。
  - WebSocket 实时推送给在线用户；离线用户登录后从表里拉未读。

**技术点**：
- 通知实体一般包含：
  - `user_id`：接收方
  - `type`：通知类型（好友申请、群邀请、群变更等）
  - `message`：展示文案（后端拼好）
  - `extra`：JSON 扩展信息（例如操作人、目标群 ID 等）
  - `read`：是否已读，支持 **按条 / 批量** 标记已读
- 控制器提供：
  - 创建通知接口（供业务服务内部调用）。
  - 分页查询 + 未读统计接口。
  - 标记全部已读 / 根据 ID 列表标记已读接口，方便前端做精细交互。

**典型面试题**：
- 设计一个 **统一通知中心**，支持多种业务（好友、群、系统公告）复用，怎么建表、怎么划分 type？
- 如何保证通知“既能实时推、又不会丢失”？

**简历示例表述**：
- 设计并实现可复用的 **通知中心**，支持好友申请、群邀请等多种通知类型，采用 **数据库持久化 + WebSocket 推送** 的方式实现“离线可补、在线实时”的一致体验，并支持按条与批量已读。

---

## 4. 基础设施与横切能力

### 4.1 统一响应与错误码

- 所有 HTTP 接口统一返回 `Result<T>`：
  - `code`、`message`、`data`、`timestamp`。
- 错误码集中定义：
  - 用户相关：1001 用户名已存在，1002 账户或密码错误，1003 Token 过期。
  - 好友相关：2001 好友已存在，2002 申请已发送，2004 不能加自己。
  - 消息相关：3001 发送失败，3004 撤回时间已过等。
  - 群组相关：4001 群不存在，4002 非群成员，4004 群已满等。

**价值**：
- 提升前后端协作效率；
- 便于前端统一处理错误场景；
- 支持日志 / 监控按错误码聚合分析。

**面试题**：
- 如何设计统一响应格式和错误码体系？
- 业务异常 vs 系统异常如何区分与处理？

**简历表述**：
- 设计统一的 **Result + 错误码** 规范，覆盖用户/好友/消息/群组等场景，统一前后端交互协议，简化错误处理逻辑。

---

### 4.2 认证拦截与 WebMvc 配置

- `WebMvcConfig` 注册 JWT 拦截器：
  - `addPathPatterns("/api/**")` 全局拦截；
  - `excludePathPatterns("/api/user/register", "/api/user/login", "/api/friend/internal/**")` 放行注册、登录和内部 RPC 接口。
- 优点：
  - 控制粒度清晰；
  - 内部服务间调用可走单独的 internal 前缀，无需 token。

**面试题**：
- 在 SpringBoot 中如何实现 **统一认证拦截**？
- 内部服务调用是否应该走同样的认证机制？如何设计 internal 接口？

**简历表述**：
- 通过自定义 **JWT 拦截器 + WebMvc 配置** 实现后端统一鉴权，并为内部服务间调用设计 `/internal` 前缀接口，简化服务间访问控制。

---

### 4.3 Redis 的使用场景

- Token 黑名单 / 会话缓存
- 用户在线状态 / 心跳信息（预留）
- 热点数据（如常用联系人、未读数聚合）

**面试题**：
- 什么时候选择把数据放在 Redis，而不是 MySQL？
- 如何处理 Redis 中数据与 MySQL 的一致性问题？

**简历表述**：
- 在项目中使用 **Redis** 缓存用户会话与热点数据，减少数据库压力，并通过合理的过期策略与回源逻辑保证与 MySQL 之间的数据一致性。

---

## 5. 可用于面试的综合问题示例

1. 设计一个类似微信的 IM 系统，你会如何拆分微服务？用户、消息、群组分别承担什么职责？
2. 即时通讯中的 **长连接** 和 **短连接** 有什么区别？为什么选择 WebSocket？
3. 如何设计 **消息未读数** 与 **会话列表**？在多端登录、并发阅读场景下如何保证正确？
4. 好友系统中如何避免重复加好友、重复发送申请？数据库唯一约束和业务幂等如何配合？
5. 群聊和单聊在表结构设计上有什么异同？如果未来要支持超大群（10w+）如何演进？
6. 通知中心如何抽象，才能同时支撑好友申请、群邀请、系统公告等多种类型？
7. 在这个 IM 系统里，Redis、MySQL、WebSocket、JWT 分别承担了什么角色？它们之间是如何协作的？

---

## 6. 简历写法整合示例

下面是可以直接放在简历项目经历里的一个整合描述示例（可根据实际情况删减）：

> 负责基于 **Spring Boot 3.x + MyBatis + Redis + WebSocket** 的即时通讯系统后端设计与开发，采用微服务拆分 `用户服务`、`消息服务` 等模块：
>
> - **用户与认证**：实现用户注册/登录/登出、资料维护、用户搜索等功能，引入 **JWT + Redis** 认证方案，使用 **BCrypt** 加密存储密码，统一封装 `Result` + 错误码规范。
> - **好友 & 群组**：设计 `friend`、`friend_request`、`group`、`group_member` 等核心表结构，实现好友申请、双向关系维护、黑名单与免打扰，以及群创建/邀请/加入/退群/角色管理逻辑，并通过事务保证数据一致性。
> - **实时通信与通知**：基于 **Spring WebSocket + STOMP** 搭建长连接通道，支持单聊/群聊消息与系统通知推送；设计可复用的通知中心，将好友申请、群邀请等事件持久化，并通过 WebSocket 实时推送给在线用户。
> - **性能与扩展性**：在数据库层面通过合理的主键与联合索引优化历史消息与会话查询效率，利用 Redis 缓存热点数据，预留 Kafka、Nacos、Gateway 等组件以支持后续水平扩展与网关统一接入。

---

*（本文件仅总结广场模块以外的后端内容；广场模块的帖子、可见范围、广场通知等已在代码与其他文档中实现和说明。）*
