# 仿微信 IM 即时通讯系统（后端）简历写法示例

> 说明：本文件是专门给简历用的“项目经历”文案，风格参考苍穹外卖 / 黑马点评那类教学项目，重点突出高并发消息、Kafka + Redis、WebSocket、微服务拆分等亮点。你可以按需精简或组合使用。

---

## 一、项目概述（可以放在简历开头的一句话）

- 基于 **Spring Boot 3.x + MyBatis + Redis + Kafka + WebSocket** 的仿微信即时通讯系统，采用微服务架构，支持用户注册登录、好友关系管理、单聊 / 群聊、通知推送等核心 IM 能力。

> 精简版本：
>
> - 基于 Spring Boot + WebSocket + Kafka + Redis 实现的仿微信即时通讯系统后端，负责用户、好友、群组、消息与通知等核心模块的设计与开发。

---

## 二、技术栈与架构要点

**后端技术栈**：
- **框架**：Spring Boot 3.x、Spring MVC、Spring WebSocket、Spring Kafka
- **持久层**：MyBatis / MyBatis-Plus + MySQL 8
- **缓存与会话**：Redis 7.x
- **消息中间件**：Apache Kafka 3.x
- **认证与安全**：JWT、BCrypt 密码加密、自定义拦截器
- **对象存储**：MinIO
- **部署与基础设施**：Docker Compose（MySQL / Redis / Kafka / MinIO / 多服务编排）

**架构特点**：
- 微服务拆分 `im-user-service`（用户 & 好友 & 群组）、`im-message-service`（消息 & WebSocket & 异步持久化），模块边界清晰，方便水平扩展。
- 前后端分离，前端 Vue3 + Element Plus，后端提供 REST + WebSocket + Kafka 异步链路。

简历可写示例：

> - 技术栈：Spring Boot 3.x、Spring WebSocket、Spring Kafka、MyBatis、MySQL、Redis、JWT、MinIO、Docker 等。
> - 架构：前后端分离 + 微服务拆分用户域与消息域，引入 Kafka + Redis 构建高并发消息链路。

---

## 三、主要职责与模块拆分（详细版，可选其一粘贴）

### 1. 用户与认证中心

> 建议保留 2~3 条，突出 JWT + Redis、安全和统一响应规范。

- 负责用户注册 / 登录 / 登出、资料维护、用户搜索等业务接口开发；设计 `user` 表结构及索引，支持按用户名 / 手机号等条件查询。
- 引入 **JWT + Redis** 的认证方案：登录后签发带过期时间的 Token，并写入 Redis，用于实现单点登录与 Token 主动失效；在所有 `/api/**` 接口前增加 JWT 拦截器，统一解析和校验 Token，将 `userId` 写入 ThreadLocal，简化后续业务代码。
- 使用 **BCrypt** 对用户密码加盐哈希存储，避免明文或可逆加密；配合统一错误码与 `Result<T>` 响应结构，规范前后端交互协议。

**可用简历句式**：

> - 负责用户中心模块，实现注册 / 登录 / 资料维护 / 搜索用户等接口，引入 JWT + Redis 的认证机制和 BCrypt 密码加密，设计统一的 `Result + 错误码` 规范，统一封装异常处理和响应格式。

---

### 2. 好友与群组系统

> 对标苍穹外卖 / 黑马点评里的“订单模块 / 商家模块”，这里是“好友 & 群组模块”。

- 设计 `friend`、`friend_request` 等核心表结构，支持好友申请、同意 / 拒绝、删除（软删除）、备注名等完整流程，通过唯一索引 `uk_user_friend(user_id, friend_id)` + 业务幂等校验，避免重复加好友和重复发起申请。
- 负责好友申请处理逻辑的事务设计：同意申请时一次性更新申请状态，并为双方插入 / 恢复双向好友记录；删除好友时软删除双方关系，保证关系一致性。
- 实现黑名单与免打扰功能：
  - 设计 `blacklist` 表与相关接口，支持拉黑 / 取消拉黑、黑名单列表查询；
  - 为消息服务提供内部接口 `/api/friend/internal/check-blocked`，在发送消息前校验是否被对方拉黑；
  - 在 `friend` 表中增加 `muted` 字段，用于控制消息通知是否推送，提升用户体验。
- 负责群组与成员管理模块：
  - 设计 `group`、`group_member`、`group_invitation` 等表结构；
  - 支持创建群组、邀请 / 处理邀请、加入 / 退出群组，以及群主 / 管理员 / 普通成员多角色权限控制（如踢人、转让群主等）。

**可用简历句式**：

> - 设计好友与群组数据模型（`friend`、`friend_request`、`group`、`group_member` 等），实现好友申请、黑名单、免打扰以及群邀请 / 加群 / 退群 / 角色管理等完整流程，通过事务和唯一约束保证关系数据一致性，并为消息服务提供内部接口用于拉黑校验。

---

### 3. 实时消息与高并发处理（Kafka + Redis 亮点）

> 这一块是项目最大的亮点，重点写“消息收发链路”和“削峰异步化”。

#### 3.1 WebSocket + STOMP 实时通道

- 基于 **Spring WebSocket + STOMP** 搭建长连接通道：
  - 客户端连接时在 STOMP `CONNECT` 帧中携带 JWT Token，服务端在 `ChannelInterceptor` 中统一鉴权并将 `userId` 绑定到会话；
  - 支持多种目的地：单聊队列 `/queue/chat/{userId}`、群聊 `/topic/chat/{groupId}`、通知队列 `/queue/notification/{userId}` 等。
- 设计心跳机制与连接管理策略，保证连接在网络抖动场景下可恢复，防止长时间空闲连接占用资源。

#### 3.2 Kafka + Redis 异步消息链路（高并发亮点）

- 针对**高并发消息写入 MySQL 的瓶颈问题**，设计了“**Redis 缓存 + Kafka 异步持久化 + 补偿任务**”的消息落库方案：
  1. 前端通过 WebSocket 发送消息到消息服务；
  2. 消息服务为消息生成全局唯一 ID（雪花算法 `SnowflakeIdGenerator`），先将消息写入 Redis（如 `im:msg:{id}`），并标记 `persist_status = PENDING`；
  3. 同时将消息 ID 发送到 Kafka Topic（如 `im-message-private`）；
  4. Kafka 消费者异步从 Topic 消费消息，执行业务持久化逻辑：将消息写入 MySQL `message` 表，并更新 Redis 中该消息的 `persist_status = PERSISTED`；
  5. 定时补偿任务（`MessageCompensateTask`）会定期扫描 Redis 中持久化状态长时间为 `PENDING` 的消息，重新投递到 Kafka，避免由于临时故障导致的数据丢失。
- 通过 Kafka 的多分区机制（如 10 分区），将消息写入压力分散到多个消费线程，实现**削峰填谷**，提升整个系统在高并发场景下的吞吐能力和可靠性。
- 在消息持久化链路中增加关键日志与监控点（“消息已缓存并发送到 Kafka”、“消息持久化成功”、“补偿任务重试”等），方便排查和观测实时状态。

**这一段可以直接写到简历里**：

> - 负责即时消息高并发处理链路设计：基于 **Redis + Kafka + 异步消费者 + 定时补偿任务** 实现消息落库，消息先写入 Redis 并发送到 Kafka，由消费者异步持久化到 MySQL，并通过补偿任务处理极端失败场景，有效削峰填谷，提升系统在高并发场景下的吞吐能力与可靠性。

#### 3.3 会话与未读数设计（可补充）

- 设计 `message`、`message_read`、`conversation` 表结构，支持按会话维度管理最近一条消息、未读数以及历史消息查询。
- 在消息到达和用户阅读时分别更新 `conversation.unread_count` 与 `message_read` 记录，为前端会话列表和红点提醒提供数据支持。

**可用简历句式**：

> - 设计消息 / 已读 / 会话三层数据模型，支持多端同步的未读计数与历史消息查询，为会话列表和消息红点提醒提供数据支撑。

---

### 4. 通知系统与 WebSocket 推送

> 好友申请、群邀请、群事件通知等都可以归入“通知中心”。

- 设计通用通知表结构，包含 `user_id`、`type`、`message`、`extra`、`read` 等字段，支持好友申请、群邀请等多种通知类型复用；
- 提供创建通知、分页查询、按条 / 批量标记已读等接口，并通过 WebSocket 实时推送给在线用户；离线用户登录后可直接从 DB 拉取未读通知列表；
- 在前端实现“未读 / 已读”分 Tab 展示，以及“点击某条即标记已读 / 一键全部已读”等交互，提高用户对通知的掌控感。

**可用简历句式**：

> - 设计可复用的通知中心，将好友申请、群邀请等事件统一持久化并通过 WebSocket 实时推送，支持按条与批量已读控制，前端提供“未读 / 已读”分 Tab 展示，提升用户对通知的可见性和可控性。

---

### 5. 运维与基础设施

- 使用 Docker Compose 编排 MySQL、Redis、Kafka、MinIO 以及多个 Spring Boot 服务，提供一键启动的本地开发与演示环境；
- 将 Kafka、Redis、数据库等配置抽取到 `application.yml`，通过环境变量控制生产 / 开发环境连接信息，方便部署与迁移；
- 为 Kafka 消费者配置手动提交 offset、批量拉取记录数、反压控制等参数，避免消费端过载。

**可用简历句式**：

> - 使用 Docker Compose 搭建本地一体化开发环境（MySQL / Redis / Kafka / MinIO / 多微服务），并为 Kafka 消费者配置手动提交 offset 与合理的消费参数，保证消息链路的可观测性与稳定性。

---

## 四、项目亮点（可以在简历中单独列出“项目难点&亮点”）

> 建议在简历里单独有一个“小标题：项目难点 & 亮点”，从下面挑 2~3 条最有感觉的写。

1. **高并发消息处理链路设计**：
   - 难点：即时通讯在高并发场景下，若每条消息都同步写 MySQL，容易成为瓶颈甚至拖垮数据库；同时要保证消息不丢失、可追踪。
   - 方案：
     - 采用 Redis 作为消息缓存与状态存储，Kafka 作为异步消息队列；
     - 发送消息时先写 Redis 再投递 Kafka，由消费者异步写入 MySQL；
     - 补偿任务定期扫描持久化状态，重试异常消息，提升可靠性。
   - 价值：整体消息写入链路从同步阻塞改为异步解耦，具备较好的扩展性和抗压能力。

2. **WebSocket + JWT 鉴权与多类型消息路由**：
   - 难点：长连接需要考虑鉴权、会话管理、心跳、断线重连以及不同业务类型（单聊 / 群聊 / 通知）的路由。
   - 方案：
     - 基于 Spring WebSocket + STOMP，将不同业务映射到不同 destination（队列 / 主题）；
     - 在连接建立阶段统一校验 JWT，并将用户身份与 WebSocket 会话绑定；
     - 通过心跳机制与客户端重连策略提升连接稳定性。

3. **好友 / 群组关系一致性与幂等设计**：
   - 通过唯一索引 + 事务 + 状态机，避免重复添加好友、重复处理申请，同时保证双向关系在边界场景（撤回、重新添加等）下始终一致。

4. **通用通知中心**：
   - 抽象出统一的通知模型，支持扩展到更多通知类型（例如系统公告、活动提醒），前端通过统一组件渲染，降低后续功能迭代成本。

---

## 五、不同长度的简历示例

### 5.1 简短版（1 段话）

> 仿微信即时通讯系统（后端）——基于 Spring Boot 3.x + MyBatis + Redis + Kafka + WebSocket 的 IM 系统，采用微服务拆分用户服务与消息服务，负责用户认证、好友 / 群组管理、消息与通知等核心模块开发；通过 Redis + Kafka + 异步消费者 + 补偿任务设计高并发消息落库链路，并基于 Spring WebSocket + STOMP 实现单聊 / 群聊 / 通知的实时推送。

### 5.2 标准版（推荐）

> 仿微信即时通讯系统（后端）  |  Spring Boot / MyBatis / Redis / Kafka / WebSocket
>
> - 负责基于 Spring Boot 3.x + WebSocket + Kafka + Redis 的 IM 系统后端设计与开发，采用微服务拆分用户服务与消息服务，提供用户、好友、群组、消息与通知等核心能力。
> - 设计好友与群组数据模型（`user`、`friend`、`friend_request`、`group`、`group_member` 等），实现好友申请、黑名单、免打扰以及群邀请 / 加群 / 退群 / 角色管理等完整流程，通过事务和唯一约束保证关系数据一致性。
> - 针对消息高并发写库瓶颈，采用 **Redis + Kafka + 异步消费者 + 定时补偿任务** 的架构，将消息写入链路从同步改为异步解耦，消息先缓存到 Redis 再投递 Kafka，由消费者异步持久化到 MySQL，并通过补偿任务处理异常场景，提升系统吞吐能力与可靠性。
> - 基于 Spring WebSocket + STOMP 搭建长连接通道，统一接入单聊 / 群聊 / 通知等多种消息类型，引入 JWT 鉴权与心跳机制保障连接安全与稳定；同时设计通用通知中心，支持好友申请、群邀请等通知的持久化、分页查询和按条 / 批量已读控制。

### 5.3 更长版（用于“主要项目经历”）

> 仿微信即时通讯系统（后端）  |  Spring Boot / MyBatis / MySQL / Redis / Kafka / WebSocket / JWT
>
> - 项目背景：模仿微信核心功能的即时通讯系统，包含用户注册登录、好友关系、群聊、实时消息推送、通知中心等模块，目标是搭建一套可扩展的 IM 后端架构，并针对消息高并发场景进行架构设计与演练。
> - 技术栈：Spring Boot 3.x、Spring WebSocket + STOMP、Spring Kafka、MyBatis / MyBatis-Plus、MySQL 8、Redis 7、JWT 认证、BCrypt 密码加密、MinIO 对象存储、Docker Compose 环境编排等。
> - 主要工作：
>   - 负责用户与认证中心模块，实现注册 / 登录 / 登出、资料维护、用户搜索等接口，引入 JWT + Redis 的认证机制和统一 `Result + 错误码` 规范，封装全局异常处理与参数校验。
>   - 设计好友与群组数据模型，开发好友申请、黑名单、免打扰、群邀请、加群 / 退群、角色管理等功能，通过事务和唯一约束保证双向关系的一致性，并提供内部接口供消息服务校验拉黑状态。
>   - 负责即时消息与通知模块设计：基于 Spring WebSocket + STOMP 实现单聊 / 群聊实时通信，客户端通过 JWT 认证建立长连接，服务器按会话维度维护消息与未读数；同时抽象通用通知中心，支持好友申请、群邀请等事件的持久化与 WebSocket 推送。
>   - 针对高并发消息写库压力，采用 Redis + Kafka + 异步消费者 + 定时补偿任务的架构，将消息发送与持久化解耦：消息先缓存到 Redis 并发送至 Kafka Topic，由消费者异步写入 MySQL 并更新状态，补偿任务定期检查长时间未持久化的消息重新投递，显著提升系统的吞吐能力和故障恢复能力。
>   - 使用 Docker Compose 编排 MySQL / Redis / Kafka / MinIO 及多个 Spring Boot 服务，为项目提供一键启动的本地开发与演示环境，方便联调与验证。

---

> 建议：
> - 面试时从“项目概述 + 架构 + 你负责的模块 + 一个重点难点（Kafka+Redis高并发消息链路）”这条主线来讲；
> - 简历上可以用 **5.2 标准版** 为主，根据篇幅酌情删减 1~2 条细节；
> - 如果以后你再补充性能压测数据（例如 QPS、消息吞吐量等），可以在亮点部分追加量化结果，让说服力更强。
