# å•èŠæ¶ˆæ¯å¼‚æ­¥æŒä¹…åŒ–å®æ–½æŒ‡å—

## ğŸ“¦ å·²å®Œæˆçš„ä»£ç 

### 1. é…ç½®æ–‡ä»¶

âœ… **application.yml** - å·²æ·»åŠ Kafkaé…ç½®
```yaml
spring.kafka.bootstrap-servers: localhost:9092
im.message.kafka-topic: im-message-private
im.message.kafka-partitions: 10
```

### 2. å®ä½“ç±»

âœ… **Message.java** - å·²æ·»åŠ `persistStatus`å­—æ®µ
âœ… **RedisKeyConstant.java** - Redis Keyå¸¸é‡ç±»

### 3. æ ¸å¿ƒæœåŠ¡

âœ… **MessageCacheService.java** - ç¼“å­˜æœåŠ¡æ¥å£
âœ… **MessageCacheServiceImpl.java** - ç¼“å­˜æœåŠ¡å®ç°
  - cacheAndSendToKafka() - ç¼“å­˜æ¶ˆæ¯å¹¶å‘é€åˆ°Kafka
  - getConversationMessagesFromCache() - ä»Redisè·å–ä¼šè¯æ¶ˆæ¯
  - markMessageAsRecalled() - æ ‡è®°æ¶ˆæ¯æ’¤å›
  - isMessageDeleted() - æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åˆ é™¤

### 4. Kafkaæ¶ˆè´¹è€…

âœ… **MessageKafkaConsumer.java** - å¼‚æ­¥æŒä¹…åŒ–æ¶ˆè´¹è€…
  - handlePersist() - æŒä¹…åŒ–æ¶ˆæ¯åˆ°MySQL
  - handleRecall() - å¤„ç†æ’¤å›äº‹ä»¶
  - ä¸‰æ¬¡æ’¤å›æ£€æŸ¥æœºåˆ¶
  - å¹‚ç­‰æ€§ä¿è¯

### 5. è¡¥å¿ä»»åŠ¡

âœ… **MessageCompensateTask.java** - å®šæ—¶è¡¥å¿ä»»åŠ¡
  - æ¯åˆ†é’Ÿæ£€æŸ¥PENDINGè¶…æ—¶æ¶ˆæ¯
  - è‡ªåŠ¨é‡æ–°å‘é€åˆ°Kafka

### 6. Mapperå±‚

âœ… **MessageMapper.java** - å·²æ·»åŠ æ–¹æ³•ï¼š
  - deleteById()
  - updateById()
  - updateRecallStatus()

âœ… **MessageDeleteMapper.java** - å·²æ·»åŠ æ–¹æ³•ï¼š
  - selectByUserAndMessage()

âœ… **MessageMapper.xml** - SQLå®ç°å·²å®Œæˆ
âœ… **MessageDeleteMapper.xml** - SQLå®ç°å·²å®Œæˆ

### 7. å¯åŠ¨ç±»

âœ… **MessageApplication.java** - å·²æ·»åŠ `@EnableScheduling`

---

## ğŸš€ ä¸‹ä¸€æ­¥ï¼šé›†æˆåˆ°MessageServiceImpl

### éœ€è¦ä¿®æ”¹çš„æ–¹æ³•

#### 1. sendMessage() - å‘é€æ¶ˆæ¯

**å½“å‰é€»è¾‘**ï¼š
```java
// ç›´æ¥å†™æ•°æ®åº“
Message message = new Message();
// ... è®¾ç½®å±æ€§
messageMapper.insert(message); // â† åŒæ­¥å†™åº“
```

**æ–°é€»è¾‘ï¼ˆä»…å•èŠï¼‰**ï¼š
```java
@Autowired
private MessageCacheService messageCacheService;

@Autowired
private com.im.common.util.SnowflakeIdGenerator idGenerator; // éœ€è¦æ·»åŠ 

public Long sendMessage(Long fromUserId, MessageDTO messageDTO) {
    // ... å‚æ•°éªŒè¯ ...
    
    // åˆ›å»ºæ¶ˆæ¯
    Message message = new Message();
    
    // ä½¿ç”¨é›ªèŠ±ç®—æ³•ç”ŸæˆID
    message.setId(idGenerator.nextId());
    message.setFromUserId(fromUserId);
    message.setToId(toId);
    message.setChatType(messageDTO.getChatType());
    message.setMsgType(messageDTO.getMsgType());
    message.setContent(messageDTO.getContent());
    message.setUrl(messageDTO.getUrl());
    message.setStatus(1);
    message.setSendTime(LocalDateTime.now());
    
    // ===== å…³é”®ä¿®æ”¹ =====
    if (messageDTO.getChatType() == 1) {
        // å•èŠï¼šå¼‚æ­¥æŒä¹…åŒ–
        message.setPersistStatus("PENDING");
        messageCacheService.cacheAndSendToKafka(message);
    } else {
        // ç¾¤èŠï¼šä¿æŒåŒæ­¥å†™åº“
        messageMapper.insert(message);
    }
    
    // ... æ›´æ–°ä¼šè¯ ...
    // ... æ¨é€é€šçŸ¥ ...
    
    return message.getId();
}
```

#### 2. getHistoryMessages() - æŸ¥è¯¢å†å²

**æ–°é€»è¾‘ï¼ˆä»…å•èŠï¼‰**ï¼š
```java
public Map<String, Object> getHistoryMessages(Long userId, Long targetId, Integer chatType, Integer page, Integer size) {
    
    List<Message> result = new ArrayList<>();
    
    if (chatType == 1) {
        // å•èŠï¼šå…ˆæŸ¥Redis
        String conversationId = messageCacheService.generateConversationId(userId, targetId);
        List<Message> cachedMessages = messageCacheService
            .getConversationMessagesFromCache(conversationId, 100);
        
        // è¿‡æ»¤å·²åˆ é™¤çš„æ¶ˆæ¯
        for (Message msg : cachedMessages) {
            if (!messageCacheService.isMessageDeleted(userId, msg.getId())) {
                result.add(msg);
            }
        }
    }
    
    // Redisä¸å¤Ÿï¼ŒæŸ¥MySQLè¡¥å……
    if (result.size() < size) {
        int offset = (page - 1) * size;
        List<Message> dbMessages = messageMapper.selectHistoryMessages(
            userId, targetId, chatType, offset, size
        );
        
        // åˆå¹¶å»é‡
        Set<Long> existIds = result.stream()
            .map(Message::getId)
            .collect(Collectors.toSet());
        
        for (Message msg : dbMessages) {
            if (!existIds.contains(msg.getId())) {
                result.add(msg);
            }
        }
    }
    
    // æ’åº
    result.sort((m1, m2) -> m2.getSendTime().compareTo(m1.getSendTime()));
    
    // ... åˆ†é¡µè¿”å› ...
}
```

#### 3. recallMessage() - æ’¤å›æ¶ˆæ¯

**æ–°é€»è¾‘ï¼ˆä»…å•èŠï¼‰**ï¼š
```java
public void recallMessage(Long messageId, Long userId) {
    // ... æƒé™éªŒè¯ ...
    // ... æ—¶é—´éªŒè¯ ...
    
    // æŸ¥è¯¢æ¶ˆæ¯
    Message msg = messageCacheService.getMessageFromCache(messageId);
    if (msg == null) {
        msg = messageMapper.selectById(messageId);
    }
    
    if (msg.getChatType() == 1) {
        // å•èŠï¼šæ ¹æ®persistStatuså¤„ç†
        String persistStatus = msg.getPersistStatus();
        messageCacheService.markMessageAsRecalled(messageId, persistStatus);
    } else {
        // ç¾¤èŠï¼šä¿æŒåŸé€»è¾‘
        messageMapper.recallMessage(messageId, userId);
    }
    
    // ... WebSocketé€šçŸ¥ ...
}
```

#### 4. deleteMessage() - åˆ é™¤æ¶ˆæ¯

**ä¿®æ”¹ï¼ˆæ‰€æœ‰ç±»å‹ï¼‰**ï¼š
```java
public void deleteMessage(Long messageId, Long userId) {
    // ... éªŒè¯ ...
    
    // å†™å…¥åˆ é™¤è®°å½•
    MessageDelete deleteRecord = new MessageDelete();
    deleteRecord.setUserId(userId);
    deleteRecord.setMessageId(messageId);
    messageDeleteMapper.insert(deleteRecord);
    
    // åŒæ—¶æ›´æ–°Redis
    messageCacheService.markMessageAsDeleted(userId, messageId);
}
```

---

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

### å‰ç½®æ¡ä»¶

- [x] Kafkaå·²å®‰è£…å¹¶å¯åŠ¨
- [x] Rediså·²é…ç½®AOFæŒä¹…åŒ–
- [ ] é›ªèŠ±ç®—æ³•IDç”Ÿæˆå™¨å·²å®ç°
- [ ] æ•°æ®åº“è¿ç§»SQLå·²æ‰§è¡Œ

### ä»£ç å®æ–½

- [x] é…ç½®æ–‡ä»¶å·²æ›´æ–°
- [x] å®ä½“ç±»å·²ä¿®æ”¹
- [x] ç¼“å­˜æœåŠ¡å·²å®ç°
- [x] Kafkaæ¶ˆè´¹è€…å·²å®ç°
- [x] è¡¥å¿ä»»åŠ¡å·²å®ç°
- [x] Mapperå±‚å·²æ‰©å±•
- [ ] MessageServiceImplå·²é›†æˆï¼ˆéœ€è¦æ‰‹åŠ¨ä¿®æ”¹ï¼‰

### æµ‹è¯•éªŒè¯

- [ ] å‘é€æ¶ˆæ¯ï¼š<10mså“åº”
- [ ] Redisç¼“å­˜å‘½ä¸­
- [ ] Kafkaæ¶ˆè´¹æˆåŠŸ
- [ ] è¡¥å¿ä»»åŠ¡è¿è¡Œæ­£å¸¸
- [ ] å¿«é€Ÿæ’¤å›ï¼ˆPENDINGçŠ¶æ€ï¼‰
- [ ] å»¶è¿Ÿæ’¤å›ï¼ˆPERSISTEDçŠ¶æ€ï¼‰
- [ ] æ¶ˆæ¯åˆ é™¤åŠŸèƒ½æ­£å¸¸

---

## ğŸ”§ é›ªèŠ±ç®—æ³•IDç”Ÿæˆå™¨å®ç°

éœ€è¦åœ¨`im-common`æ¨¡å—æ·»åŠ ï¼š

```java
package com.im.common.util;

import org.springframework.stereotype.Component;

@Component
public class SnowflakeIdGenerator {
    
    private final long workerId = 1L;
    private final long datacenterId = 1L;
    private final long sequenceBits = 12L;
    private final long workerIdBits = 5L;
    private final long datacenterIdBits = 5L;
    
    private final long maxWorkerId = ~(-1L << workerIdBits);
    private final long maxDatacenterId = ~(-1L << datacenterIdBits);
    private final long sequenceMask = ~(-1L << sequenceBits);
    
    private final long workerIdShift = sequenceBits;
    private final long datacenterIdShift = sequenceBits + workerIdBits;
    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("Clock moved backwards");
        }
        
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) & sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        return ((timestamp - 1640995200000L) << timestampLeftShift) |
               (datacenterId << datacenterIdShift) |
               (workerId << workerIdShift) |
               sequence;
    }
    
    private long tilNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```

---

## ğŸš¦ å¯åŠ¨é¡ºåº

1. **å¯åŠ¨Kafka**
   ```bash
   bin/zookeeper-server-start.sh config/zookeeper.properties
   bin/kafka-server-start.sh config/server.properties
   ```

2. **åˆ›å»ºTopic**
   ```bash
   bin/kafka-topics.sh --create \
     --topic im-message-private \
     --partitions 10 \
     --replication-factor 1 \
     --bootstrap-server localhost:9092
   ```

3. **æ‰§è¡Œæ•°æ®åº“è¿ç§»**
   ```bash
   mysql -u root -p < message_async_persist.sql
   ```

4. **å¯åŠ¨æœåŠ¡**
   ```bash
   # å¯åŠ¨æ¶ˆæ¯æœåŠ¡
   cd im-message-service
   mvn spring-boot:run
   ```

---

## ğŸ“Š ç›‘æ§æŒ‡æ ‡

### Redisç›‘æ§
```bash
redis-cli INFO stats
# å…³æ³¨ï¼škeyspace_hits, keyspace_misses
```

### Kafkaç›‘æ§
```bash
bin/kafka-consumer-groups.sh \
  --bootstrap-server localhost:9092 \
  --describe \
  --group im-message-consumer
# å…³æ³¨ï¼šLAGï¼ˆæ¶ˆè´¹å»¶è¿Ÿï¼‰
```

### åº”ç”¨æ—¥å¿—
```
å…³é”®æ—¥å¿—ï¼š
- "æ¶ˆæ¯å·²ç¼“å­˜å¹¶å‘é€åˆ°Kafka"
- "æ¶ˆæ¯æŒä¹…åŒ–æˆåŠŸ"
- "è¡¥å¿ä»»åŠ¡ï¼šå‘ç°æœªæŒä¹…åŒ–æ¶ˆæ¯"
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **ç¾¤èŠæ¶ˆæ¯æš‚ä¸ä½¿ç”¨å¼‚æ­¥**ï¼šç¾¤èŠæ¶ˆæ¯é‡å¤§ï¼Œéœ€è¦é¢å¤–ä¼˜åŒ–ï¼Œå½“å‰ä¿æŒåŒæ­¥å†™åº“

2. **IDç”Ÿæˆå™¨**ï¼šå¿…é¡»ä½¿ç”¨é›ªèŠ±ç®—æ³•ç­‰åˆ†å¸ƒå¼IDï¼Œä¸èƒ½ç”¨MySQLè‡ªå¢

3. **æ¶ˆæ¯é¡ºåº**ï¼šKafkaæŒ‰conversationIdåˆ†åŒºï¼Œä¿è¯åŒä¸€ä¼šè¯æ¶ˆæ¯æœ‰åº

4. **æ•°æ®ä¸€è‡´æ€§**ï¼š
   - Redisæœ‰AOFæŒä¹…åŒ–
   - Kafkaæœ‰3å‰¯æœ¬
   - è¡¥å¿ä»»åŠ¡å…œåº•

5. **æ’¤å›ç«æ€**ï¼šä¸‰æ¬¡æ£€æŸ¥æœºåˆ¶ä¿è¯ä¸ä¼šå‡ºç°"æ’¤å›å¤±è´¥"çš„æƒ…å†µ

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å•èŠæ¶ˆæ¯å¼‚æ­¥æŒä¹…åŒ–æ–¹æ¡ˆ.md](./å•èŠæ¶ˆæ¯å¼‚æ­¥æŒä¹…åŒ–æ–¹æ¡ˆ.md) - è¯¦ç»†æŠ€æœ¯è®¾è®¡
- [APIæ¥å£è®¾è®¡.md](../APIæ¥å£è®¾è®¡.md) - æ¥å£è§„èŒƒ

---

## ğŸ¯ ä¸‹ä¸€æ­¥ä¼˜åŒ–æ–¹å‘

1. **ç¾¤èŠå¼‚æ­¥æŒä¹…åŒ–**ï¼šç¾¤èŠæ¶ˆæ¯ä¹Ÿæ”¯æŒå¼‚æ­¥
2. **æ¶ˆæ¯å‹ç¼©**ï¼šKafkaæ¶ˆæ¯ä½¿ç”¨GZIPå‹ç¼©
3. **æ‰¹é‡æŒä¹…åŒ–**ï¼šæ¶ˆè´¹è€…æ‰¹é‡å†™å…¥MySQL
4. **è¯»å†™åˆ†ç¦»**ï¼šMySQLä¸»ä»ï¼Œè¯»æ“ä½œèµ°ä»åº“
5. **åˆ†åº“åˆ†è¡¨**ï¼šæŒ‰æ—¶é—´æˆ–ç”¨æˆ·ç»´åº¦åˆ†è¡¨
