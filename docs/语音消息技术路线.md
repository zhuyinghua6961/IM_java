# 语音消息（语音条）技术路线设计

## 1. 整体设计思路

- **音频走文件上传，消息只传元信息**：
  - 语音的二进制音频通过普通 HTTP(S) 上传到文件服务 / 静态资源服务器 / 对象存储；
  - IM 消息只发送 `msgType=VOICE` + JSON 格式的语音元信息（url、时长、大小等）。
- **复用现有 IM 基础设施**：
  - WebSocket、Kafka 异步持久化、Redis 缓存、MySQL 表结构全部复用；
  - 语音消息在后端被视为一种特殊 `msgType` 的文本消息，不引入新表。 
- **前后端协同**：
  - 前端负责录音、上传、展示与播放；
  - 后端负责文件存储、URL 生成、权限控制以及消息转发与存储。

---

## 2. 后端消息模型与存储

### 2.1 Message 表/实体约定

现有 `Message` 实体示例字段：

- `id`: Long（雪花 ID）
- `fromUserId`: Long
- `toId`: Long（单聊对方或群 ID）
- `chatType`: 1 单聊 / 2 群聊
- `msgType`: Integer
- `content`: String
- 其它：`status`、`sendTime`、`recallTime`、`persistStatus` 等

扩展方案：

- 约定一个语音类型值，例如：
  - `msgType = 2` 表示语音消息（VOICE）。
- `content` 字段存放 JSON 字符串，示例：

```json
{
  "url": "https://static.xx.com/im/audio/2025/12/01/5180xxx.m4a",
  "duration": 6.3,
  "size": 24873,
  "format": "m4a"
}
```

特点：

- 不需要改 DB 结构，只是统一约定 `msgType + content` 的格式；
- Redis 缓存（`msg:detail:{messageId}`、`msg:conv:{conversationId}`）、Kafka 消息 `data`、MySQL 持久化全部透明复用；
- 撤回、历史消息查询、补偿任务等逻辑对语音消息同样生效。

---

## 3. 语音文件上传接口设计

### 3.1 REST 接口定义

建议新增文件上传接口（可以放在 message 服务或单独 file 服务）：

- **URL**：`POST /api/files/upload/audio`
- **请求**：
  - `Content-Type: multipart/form-data`
  - 参数：
    - `file`: 语音音频二进制（Blob）
    - 可选：`fromUserId`、`conversationId`、`chatType` 等，用于审计或目录规划
- **响应**：

```json
{
  "url": "https://static.xx.com/im/audio/2025/12/01/5180xxx.m4a",
  "duration": 6.3,
  "size": 24873
}
```

### 3.2 文件存储方案

可选实现：

- **简易方案（开发/内网环境）**：
  - 直接存本地磁盘某个目录（例如 `/data/im/audio/`）；
  - 由 Nginx 把该目录映射为静态资源 URL 前缀，如 `https://static.xx.com/im/audio/`。

- **生产方案**：
  - 将文件上传到对象存储（OSS / 七牛云 / MinIO 等）；
  - 后端负责生成最终访问 URL（可带签名、限时有效）。

---

## 4. 前端录音与发送流程（Vue）

### 4.1 浏览器录音

- 使用 `navigator.mediaDevices.getUserMedia({ audio: true })` 获取音频流。
- 使用 `MediaRecorder` 录制音频：
  - 监听 `dataavailable` 事件收集音频块；
  - 停止录制后合成 `Blob`，通常为 `audio/webm` / `audio/ogg` 等浏览器支持的格式。
- 时长计算：
  - 简单：在前端记录 `startTime` / `endTime` 计算秒数；
  - 或创建 `Audio` 对象加载 Blob，读取 `duration` 字段。

### 4.2 上传并获取语音元信息

录音结束后：

```js
const form = new FormData()
form.append('file', blob, 'voice-message.webm')

const res = await axios.post('/api/files/upload/audio', form)
const { url, duration, size } = res.data
```

### 4.3 构造并发送 IM 语音消息

- 构造消息内容：

```js
const content = JSON.stringify({ url, duration, size })
```

- 通过现有 WebSocket 客户端发送消息（与文本消息共用接口）：

```js
wsClient.sendMessage({
  chatType,            // 1: 单聊, 2: 群聊
  msgType: 2,          // 约定为 VOICE
  content,             // 语音元信息 JSON 字符串
  toId,                // 单聊对方ID或群ID
  // 其他字段保持与文本消息一致
})
```

- 后端收到消息后：
  - 走现有 `WebSocket -> MessageService.sendMessage` 流程；
  - 通过 `MessageCacheService.cacheAndSendToKafka` 缓存并投递 Kafka；
  - Kafka 消费端 `MessageKafkaConsumer` 持久化到 MySQL；
  - 历史消息查询、撤回、补偿任务等逻辑保持不变。

---

## 5. 前端展示与播放

### 5.1 消息渲染

在 `Chat.vue` 中渲染消息列表时：

- 根据 `msgType` 区分语音消息：
  - 当 `msgType === VOICE`（例如 2）时：
    - 解析内容：`const voice = JSON.parse(message.content)`；
    - 从中拿到 `voice.url`、`voice.duration` 等；
    - 在气泡中展示语音条 UI：
      - 播放图标；
      - 显示秒数（如 `6"`）；
      - 可选显示简单波形或“未听/已听”标记。

### 5.2 播放逻辑

- 点击语音条时：

```js
const audio = new Audio(voice.url)
audio.play()
```

- 控制要点：
  - 同一时间只允许一个语音播放（点击新语音时暂停上一个）；
  - 播放结束后重置 UI 状态（或将其标记为“已听”）。

### 5.3 已听状态（可选增强）

- 简单方案：
  - 仅在前端维护一个 `playedMessageIds` 集合，控制“蓝点/未听”标记，本地刷新后丢失。

- 进阶方案：
  - 扩展后端协议，增加“语音已听”上报接口，类似已读回执；
  - 在 DB 或 Redis 记录哪些用户已听某条语音，用于多端同步和已听展示。

---

## 6. 边界与约束建议

- **时长限制**：
  - 限制单条语音最大时长（如 60 秒），在前端录制时达上限自动停止；
- **大小限制**：
  - 后端上传接口限制文件大小（如 1MB 以内），过大直接拒绝；
- **格式兼容**：
  - Web 端录制格式可先使用浏览器默认；
  - 若要兼容移动端或其他平台，可在服务端接入 ffmpeg 做统一转码为 m4a/aac 等常见格式；
- **安全与鉴权**：
  - 生产环境建议使用带签名的限时 URL，防止语音被无限制下载；
  - 或对静态资源服务器做 IP 白名单/鉴权控制。

---

## 7. 实施阶段建议

### Phase 1：快速可用版本（MVP）

- 后端：
  - 实现 `/api/files/upload/audio` 上传接口；
  - 文件存本地磁盘 + Nginx 静态目录，返回可访问 URL；
- 前端：
  - 集成 `MediaRecorder` 录音；
  - 上传语音文件获取 URL/时长；
  - 发送 `msgType=VOICE` 消息；
  - 聊天界面实现点击播放。

### Phase 2：工程化与体验优化

- 接入对象存储（OSS/七牛/MinIO 等），支持签名 URL 与多副本存储；
- 实现语音“未听/已听”状态同步；
- 优化语音 UI：波形、长按加速播放、倍速播放等；
- 如有需要，增加语音转文字（ASR）能力，在气泡下方展示文字摘要。

---

## 8. 与现有消息服务的关系

- 不需要改变消息服务的核心架构：
  - Kafka + Redis 异步持久化；
  - 会话级 Redis List 缓存；
  - 撤回、历史消息查询、补偿任务等机制；
- 语音消息只是 `msgType` 的一种扩展，所有基础机制天然适配：
  - 撤回语音条与撤回文本消息在后端逻辑完全一致；
  - 历史消息首屏仍然从 Redis 会话 List + DB 合并，语音消息同样参与排序与分页；
  - PENDING 补偿任务只关心消息是否持久化，不区分消息类型。

> 按照本技术路线，可以在保持当前消息服务架构稳定的前提下，较低成本地增加语音条能力，并为后续文件类/图片类消息打下通用基础。
